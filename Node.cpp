/*
 *
 * File: Node.cpp
 * Author: jtucker
 *
 * Created 12_23_16
 *
 */

#include <gmp.h>
#include <gmpxx.h>

#include "Multiplier.h"
#include "Node.h"
#include "Path.h"

const int MAX_SUB_NODES = 5;

// It should not be used.
Node::Node(){}

//Proper constructor to use for a node.  The nodeAnchor is the PTriples associated with this node
//   Multiplier must be passed by reference to avoid initializing hundreds of the objects.
//   The dir integer is to designed to tell the node which way was taken to generate this node
//   Path oldPath is the path taken to get to the reference node before.
//   The dpth parameter allows the ternary tree to terminate after initializing enough sub nodes.
Node::Node(PTriples& nodeAnchr, Multiplier& mult, int dir, Path oldPath, int dpth){
	
	depth = dpth;
	path = oldPath;
	nodeAnchor = nodeAnchr;

	//adding to the path
	if(dir==1){
		path.addUp();
	} else if (dir == 0) {
		path.addSide();
	} else if (dir == -1) {
		path.addDown();
	} else if (dir == -2) {
		//If it is the root node, then dir must be -2
		path.setRoot();
	} 

	//This function initializes the sub-nodes which come from the current node of the ternary tree	
	initializeSubNodes(mult, depth+1);

}


//This function intakes the multilier function. The depth is taken in to ensure maximum nodes are enforced;
void Node::initializeSubNodes(Multiplier& mult, int depth){
	
	//This prevents a stack overflow.
	if (depth < MAX_SUB_NODES){
		
		//The three sub nodes, up, side, down are generated by multiplying by the corresponding matrix
		//   to the node's anchor matrix.  The node's anchor PTriple multiplied by the up matrix gives the up node, etc.
		PTriples temp = mult.hit(nodeAnchor, 1);
		PTriples temp2 = mult.hit(nodeAnchor, 2);
		PTriples temp3 = mult.hit(nodeAnchor, 3);

		//Here we create the sub-nodes and attach them to the up, side, down pointers.
		up = new Node(temp, mult, 1, path, depth);
		side = new Node(temp2, mult, 0, path, depth);
		down = new Node(temp3, mult, -1, path, depth);

	}


}



